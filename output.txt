------------------------------------------------------------
Dockerfile.frontend:
------------------------------------------------------------

FROM node:18
WORKDIR /app
COPY frontend/package*.json ./
RUN npm install
COPY frontend/ ./
EXPOSE 3000
CMD ["npm", "start"]

------------------------------------------------------------
Dockerfile.backend:
------------------------------------------------------------

FROM python:3.10
WORKDIR /app
COPY backend/requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt
COPY backend/ ./
EXPOSE 5001
CMD ["watchmedo", "auto-restart", "--patterns=*.py;*.json", "--recursive", "--", "python", "app.py"]

------------------------------------------------------------
docker-compose.yml:
------------------------------------------------------------

version: "3.8"

services:
  frontend:
    build:
      context: .
      dockerfile: Dockerfile.frontend
    ports:
      - "3001:3000"
    volumes:
      - ./frontend:/app
      - /app/node_modules
    environment:
      - WDS_SOCKET_HOST=57.129.44.194
      - WDS_SOCKET_PORT=3001
    depends_on:
      - backend
    networks:
      - app-network

  backend:
    build:
      context: .
      dockerfile: Dockerfile.backend
    ports:
      - "5001:5001"
    volumes:
      - ./backend:/app
    networks:
      - app-network

networks:
  app-network:
    driver: bridge


------------------------------------------------------------
backend/app.py:
------------------------------------------------------------

# backend/app.py

import os
import json
import uuid
import logging
import threading
from flask import Flask, request, jsonify
from flask_cors import CORS
from flask_socketio import SocketIO, join_room, leave_room, emit
import eventlet

eventlet.monkey_patch()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)
app.config['DEBUG'] = True
app.config['ENV'] = 'development'

# Initialize extensions
CORS(app, resources={r"/*": {"origins": "http://57.129.44.194:3001"}})
socketio = SocketIO(app, cors_allowed_origins="*", async_mode='eventlet')

# Constants
SCORES_FILE = 'scores.json'

# Thread-safe file operations
file_lock = threading.Lock()

# Initialize scores.json if it doesn't exist
if not os.path.exists(SCORES_FILE):
    with open(SCORES_FILE, 'w') as f:
        json.dump([], f)
    logger.info("Created scores.json file.")

# In-memory structures
rooms = {}        # room_id: [player1_sid, player2_sid]
player_moves = {} # room_id: {sid: move}

def read_scores():
    with file_lock:
        try:
            with open(SCORES_FILE, 'r') as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"Error reading scores.json: {e}")
            return []

def write_scores(scores):
    with file_lock:
        try:
            with open(SCORES_FILE, 'w') as f:
                json.dump(scores, f, indent=4)
            logger.info("Scores.json updated.")
        except Exception as e:
            logger.error(f"Error writing scores.json: {e}")

@app.route('/leaderboard', methods=['GET'])
def get_leaderboard():
    scores = read_scores()
    sorted_leaderboard = sorted(scores, key=lambda x: x['score'], reverse=True)
    return jsonify(sorted_leaderboard), 200

@app.route('/submit', methods=['POST'])
def submit_score():
    data = request.json
    name = data.get('name', 'noname')
    score = data.get('score', 0)

    scores = read_scores()

    for entry in scores:
        if entry['name'] == name:
            if score > entry['score']:
                entry['score'] = score
                write_scores(scores)
                logger.info(f"Updated score for {name}: {score}")
            break
    else:
        scores.append({'name': name, 'score': score})
        write_scores(scores)
        logger.info(f"Added score for {name}: {score}")

    sorted_leaderboard = sorted(scores, key=lambda x: x['score'], reverse=True)
    socketio.emit('leaderboard_updated', {'leaderboard': sorted_leaderboard})

    return jsonify({'message': 'Score submitted successfully'}), 200

@socketio.on('connect')
def handle_connect():
    logger.info(f"Client connected: {request.sid}")
    scores = read_scores()
    sorted_leaderboard = sorted(scores, key=lambda x: x['score'], reverse=True)
    emit('leaderboard_updated', {'leaderboard': sorted_leaderboard}, room=request.sid)
    logger.info(f"Sent leaderboard to {request.sid}")

@socketio.on('find_match')
def handle_find_match():
    logger.info(f"Client {request.sid} is looking for a match.")
    for room_id, players in rooms.items():
        if len(players) == 1:
            players.append(request.sid)
            join_room(room_id)
            emit('match_found', {'room': room_id}, room=room_id)
            logger.info(f"Match found in room {room_id} for players {players}")
            return
    # Create new room
    room_id = str(uuid.uuid4())
    rooms[room_id] = [request.sid]
    player_moves[room_id] = {}
    join_room(room_id)
    emit('waiting', {'message': 'Waiting for an opponent...'}, room=request.sid)
    logger.info(f"Created room {room_id} for player {request.sid}")

@socketio.on('make_move')
def handle_make_move(data):
    room_id = data.get('room')
    move = data.get('move')
    logger.info(f"Player {request.sid} in room {room_id} made move: {move}")

    if room_id in rooms:
        player_moves[room_id][request.sid] = move
        emit('move_received', {'player': request.sid, 'move': move}, room=room_id, include_self=False)
        logger.info(f"Moves in room {room_id}: {player_moves[room_id]}")
        if len(player_moves[room_id]) == 2:
            player1, player2 = rooms[room_id]
            move1 = player_moves[room_id][player1]
            move2 = player_moves[room_id][player2]
            result1, result2 = determine_result(move1, move2)

            emit('game_result', {'your_move': move1, 'opponent_move': move2, 'result': result1}, room=player1)
            emit('game_result', {'your_move': move2, 'opponent_move': move1, 'result': result2}, room=player2)

            player_moves[room_id] = {}
    else:
        emit('error', {'message': 'Invalid room ID'}, room=request.sid)
        logger.warning(f"Invalid room {room_id} by {request.sid}")

@socketio.on('disconnect')
def handle_disconnect():
    logger.info(f"Client disconnected: {request.sid}")
    for room_id, players in list(rooms.items()):
        if request.sid in players:
            players.remove(request.sid)
            leave_room(room_id)
            logger.info(f"Removed {request.sid} from room {room_id}")
            if not players:
                del rooms[room_id]
                del player_moves[room_id]
                logger.info(f"Deleted empty room {room_id}")
            else:
                emit('opponent_left', {'message': 'Opponent has left the game.'}, room=room_id)
                del player_moves[room_id]
                logger.info(f"Room {room_id} has remaining players: {players}")
            break

def determine_result(move1, move2):
    rules = {'Rock': 'Scissors', 'Paper': 'Rock', 'Scissors': 'Paper'}
    if move1 == move2:
        return ('Draw!', 'Draw!')
    elif rules.get(move1) == move2:
        return ('You Win!', 'You Lose!')
    else:
        return ('You Lose!', 'You Win!')

if __name__ == "__main__":
    socketio.run(app, host="0.0.0.0", port=5001, debug=True)


------------------------------------------------------------
backend/requirements.txt:
------------------------------------------------------------

Flask>=2.2.5
Flask-Cors>=3.0.10
Flask-SocketIO>=5.3.3
eventlet>=0.33.0
watchdog

------------------------------------------------------------
frontend/src/App.js:
------------------------------------------------------------

import React, { useState, useEffect } from 'react';
import './App.css';
import { io } from 'socket.io-client';

const SOCKET_SERVER_URL = 'http://57.129.44.194:5001';

function App() {
  const [gameState, setGameState] = useState('menu');
  const [playerChoice, setPlayerChoice] = useState(null);
  const [opponentChoice, setOpponentChoice] = useState(null);
  const [result, setResult] = useState('');
  const [leaderboard, setLeaderboard] = useState([]);
  const [name, setName] = useState('');
  const [hasSubmittedScore, setHasSubmittedScore] = useState(false);
  const [isOnline, setIsOnline] = useState(false);
  const [socket, setSocket] = useState(null);
  const [roomId, setRoomId] = useState(null);

  // Initialize socket connection
  useEffect(() => {
    const newSocket = io(SOCKET_SERVER_URL);
    setSocket(newSocket);

    newSocket.on('connect', () => {
      console.log('Connected to backend');
    });

    newSocket.on('leaderboard_updated', (data) => {
      setLeaderboard(data.leaderboard);
    });

    newSocket.on('match_found', ({ room }) => {
      setIsOnline(true);
      setRoomId(room);
      setGameState('game');
      console.log(`Match found in room ${room}`);
    });

    newSocket.on('waiting', () => {
      setGameState('waiting');
      console.log('Waiting for opponent...');
    });

    newSocket.on('game_result', (data) => {
      setPlayerChoice(data.your_move);
      setOpponentChoice(data.opponent_move);
      setResult(data.result);
      setGameState('gameover');
      setHasSubmittedScore(false);
    });

    newSocket.on('opponent_left', (data) => {
      alert(data.message);
      resetGame();
    });

    newSocket.on('error', (data) => {
      alert(data.message);
      resetGame();
    });

    return () => {
      newSocket.disconnect();
    };
  }, []);

  // Fetch leaderboard on initial load
  useEffect(() => {
    fetchLeaderboard();
  }, []);

  // Load name from localStorage on mount
  useEffect(() => {
    const storedName = localStorage.getItem('playerName');
    if (storedName) {
      setName(storedName);
    }
  }, []);

  const fetchLeaderboard = () => {
    fetch(`${SOCKET_SERVER_URL}/leaderboard`)
      .then((res) => res.json())
      .then((data) => setLeaderboard(data))
      .catch((err) => console.error('Error fetching leaderboard:', err));
  };

  const startGame = () => setGameState('mode_selection');

  const playAI = () => {
    setIsOnline(false);
    setGameState('game');
  };

  const playOnline = () => {
    if (socket) {
      socket.emit('find_match');
    }
  };

  const handleChoice = (choice) => {
    setPlayerChoice(choice);
    if (isOnline && socket && roomId) {
      socket.emit('make_move', { move: choice, room: roomId });
    } else {
      const aiChoices = ['Rock', 'Paper', 'Scissors'];
      const aiMove = aiChoices[Math.floor(Math.random() * 3)];
      const gameResult = determineResult(choice, aiMove);
      setOpponentChoice(aiMove);
      setResult(gameResult);
      setGameState('gameover');
    }
  };

  const determineResult = (player, opponent) => {
    if (player === opponent) return 'Draw!';
    const wins = { Rock: 'Scissors', Paper: 'Rock', Scissors: 'Paper' };
    return wins[player] === opponent ? 'You Win!' : 'You Lose!';
  };

  const submitScore = () => {
    const score = result === 'You Win!' ? 1 : result === 'You Lose!' ? -1 : 0;
    const trimmedName = name.trim() || 'noname';

    if (trimmedName !== 'noname') {
      localStorage.setItem('playerName', trimmedName);
    }

    fetch(`${SOCKET_SERVER_URL}/submit`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: trimmedName, score }),
    })
      .then((res) => res.json())
      .then(() => setHasSubmittedScore(true))
      .catch((err) => console.error('Error submitting score:', err));
  };

  const resetGame = () => {
    setGameState('menu');
    setPlayerChoice(null);
    setOpponentChoice(null);
    setResult('');
    setHasSubmittedScore(false);
    setIsOnline(false);
  };

  const playAgain = () => {
    if (isOnline && socket) {
      socket.emit('find_match');
      setGameState('waiting');
    } else {
      setGameState('game');
      setPlayerChoice(null);
      setOpponentChoice(null);
      setResult('');
    }
  };

  const handleNameChange = (e) => {
    const newName = e.target.value;
    if (/^[A-Za-z0-9]{0,20}$/.test(newName)) {
      setName(newName);
    }
  };

  return (
    <div className="app">
      <div className="menu_container">
        <div className="text_display" style={{ fontSize: '4vh' }}>{name || 'noname'}</div>
      </div>

      <div className="main_container">
        {gameState === 'menu' && (
          <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
            <button className="button" onClick={startGame}>Rock, Paper, Scissors</button>
            {name && (
              <button className="button" 
                onClick={() => {localStorage.removeItem('playerName'); setName('');}}>
                Reset Name
              </button>
            )}
          </div>
        )}

        {gameState === 'mode_selection' && (
          <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
            <div className="text_display">Select Mode</div>
            <button className="button" onClick={playAI}>Versus AI</button>
            <button className="button" onClick={playOnline}>Versus Player</button>
            <button className="button" onClick={resetGame}>Back</button>
          </div>
        )}

        {gameState === 'waiting' && (
          <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
            <div className="text_display">Waiting for an opponent...</div>
            <button className="button" onClick={resetGame}>Cancel</button>
          </div>
        )}

        {gameState === 'game' && (
          <div>
            <div className="text_display">Choose Your Move</div>
            <div className="choices" style={{ display: 'flex', justifyContent: 'center' }}>
              <button className="button" onClick={() => handleChoice('Rock')}>Rock</button>
              <button className="button" onClick={() => handleChoice('Paper')}>Paper</button>
              <button className="button" onClick={() => handleChoice('Scissors')}>Scissors</button>
            </div>
          </div>
        )}

        {gameState === 'gameover' && (
          <div style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
            <div className="text_display">{playerChoice}/{opponentChoice} = {result}</div>

            <div style={{ display: 'flex', justifyContent: 'center', padding: '2vh' }}>
              {!hasSubmittedScore && (
                <div>
                  <input className="text_input" type="text" placeholder="Enter your name"
                    value={name} onChange={handleNameChange} />
                  <button className="button" onClick={submitScore}>Submit</button>
                </div>
              )}
              {hasSubmittedScore && <div className="text_display">Score submitted!</div>}
            </div>

            <div className="text_display">Leaderboard</div>

            <ul className="leaderboard">
              {leaderboard.map((entry, index) => (
                <li key={index}>{entry.score} | {entry.name}</li>
              ))}
            </ul>

            <div style={{ display: 'flex', justifyContent: 'center', marginBottom: '3vh' }}>
              <button className="button" onClick={playAgain}>Play Again</button>
              <button className="button" onClick={resetGame}>Main Menu</button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

export default App;


------------------------------------------------------------
frontend/src/App.css:
------------------------------------------------------------

/* MAIN */

* {
  background-color: #333;
  color: #FFF;
}

html, body {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
}

.app {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 64vh;
}

@media (max-aspect-ratio: 0.64) {
  .app {
    width: 100vw;
  }
}

.main_container {
  flex: 1;
  overflow-y: auto;
  height: 100vh;
}

.menu_container {
  display: flex;
  justify-content: center;
  height: 5vh;
  padding: 1vh;
}

.text_display {
  font-size: 2.5vh;
  margin: 0 1vh;
  text-align: center;
}

.button_container {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 0.7vh;
  flex-wrap: wrap;
}

.button,
.highlighted_button {
  border-color: #BBB;
  border-radius: 1vh;
  padding: 0.9vh 1.4vh;
  margin: 0.3vh;
  font-size: 2vh;
  cursor: pointer;
}

.highlighted_button {
  background-color: #777;
}

/* SCROLLBAR */

::-webkit-scrollbar {
  width: 1vh;
}

::-webkit-scrollbar-thumb {
  background: #CCC;
  border-radius: 1vh;
}

::-webkit-scrollbar-track {
  background: #888;
  border-radius: 2vh;
}

/* BLABLA */

.text_input {
  border: 2px solid #BBB;
  border-radius: 1vh;
  padding: 0.9vh 1.4vh;
  margin: 0.3vh;
  font-size: 2vh;
}

.leaderboard {
  border: 2px solid #BBB;
  border-radius: 2vh;
  padding: 1vh;
  margin: 3vh auto;
  font-size: 2vh;
  overflow-y: auto;
  max-height: 50vh;
  max-width: 50vw;
}

------------------------------------------------------------
frontend/src/index.js:
------------------------------------------------------------

// frontend/src/index.js

import React from 'react';
import ReactDOM from 'react-dom/client';
import './App.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


------------------------------------------------------------
frontend/package.json:
------------------------------------------------------------

{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-scripts": "5.0.1",
    "socket.io-client": "^4.8.0"
  },
  "scripts": {
    "start": "react-scripts start --host 0.0.0.0",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

